//// Modifications:	12/10/96 PH - changed to WideTime format//								02/14/97 PH - added timeStr()//// Notes: TZ environment variable must be set to EST5 or EST5EDT//				depending on whether or not daylight savings time is in effect//#include <time.h>#include <sys/time.h>#include <stdio.h>#include <unistd.h>#include "clock.h"// Routines to access individual words in a long int// Note: this code assumes little-endian byte ordering#define LOW_WORD(x)		(*((short *)&(x)))#define HIGH_WORD(x)	(*((short *)&(x) + 1))Clock *Clock::current = NULL;Clock::Clock(){	lastTime.high = lastTime.low = 0;	// intialize last time to zero//	::time(&zeroTime);		// get real time (GMT)	current = this;}/*** time() - get double precision time from real-time clock**** This call takes 25.76 microseconds on a 50MHz 486*/double Clock::time(void){	struct timeval tv;	struct timezone tz;	gettimeofday(&tv,&tz);	return(tv.tv_sec + 1e-6 * tv.tv_usec);}/*** timeStr() - Get time string (24 hour clock)*/char *Clock::timeStr(double curTime,short flags){	int			len;	struct	tm	*tms;	static char	timeBuff[32];	time_t	longTime = curTime;	double	dec = curTime - longTime;// PH 11/13/97/*	long sec = longTime % 86400L;	// modulo one day	int hrs = (int)(sec / 3600L);	// hours	sec -= hrs * 3600L;	int min = (int)(sec / 60L);		// minutes	sec -= min * 60;							// seconds	sprintf(timeBuff,"%2d:%.2d:%.2ld.%d",hrs,min,sec,dec);*/	tms = localtime(&longTime);	if (flags & kClockDate) {		len = sprintf(timeBuff,"%.4d-%.2d-%.2d ",								tms->tm_year+1900,tms->tm_mon+1,tms->tm_mday);	} else {	    len = 0;	}	len += sprintf(timeBuff+len,"%.2d:%.2d:%.2d",								tms->tm_hour,tms->tm_min,tms->tm_sec);	if (flags & kClockHundredths) {		len += sprintf(timeBuff+len,".%.2d",(int)(dec*100));	} else if (flags & kClockTenths) {		len += sprintf(timeBuff+len,".%.1d",(int)(dec*10));	}	if ((flags & kClockDST) && tms->tm_isdst) {        len += sprintf(timeBuff+len," DST");	}	return(timeBuff);}